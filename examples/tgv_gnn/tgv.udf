#include "udf.hpp"
#include "plugins/gnn.hpp"

#ifdef __okl__

@kernel void
magSqr(const dlong Ntotal, const dlong offset, @ restrict const dfloat *U, @ restrict dfloat *uSqr)
{
  for (dlong n = 0; n < Ntotal; ++n; @tile(p_blockSize, @outer, @inner)) {
    uSqr[n + 0 * offset] = U[n + 0 * offset] * U[n + 0 * offset] + U[n + 1 * offset] * U[n + 1 * offset] +
                           U[n + 2 * offset] * U[n + 2 * offset];
  }
}

#endif

    
gnn_t* graph = nullptr;

void printDiagnostics(nrs_t *nrs, dfloat time, int tstep)
{
  mesh_t *mesh = nrs->meshV;

  const dfloat scale = 0.5 / mesh->volume;
  magSqr(mesh->Nlocal, nrs->fieldOffset, nrs->o_U, platform->o_mempool.slice0);
  const dfloat energy = scale * platform->linAlg->innerProd(mesh->Nlocal,
                                                            platform->o_mempool.slice0,
                                                            mesh->o_LMM,
                                                            platform->comm.mpiComm,
                                                            0);

  nrs->curlKernel(mesh->Nelements,
                  0,
                  mesh->o_vgeo,
                  mesh->o_D,
                  nrs->fieldOffset,
                  nrs->o_U,
                  platform->o_mempool.slice0);
  magSqr(mesh->Nlocal, nrs->fieldOffset, platform->o_mempool.slice0, platform->o_mempool.slice3);
  const dfloat enstrophy = scale * platform->linAlg->innerProd(mesh->Nlocal,
                                                               platform->o_mempool.slice3,
                                                               mesh->o_LMM,
                                                               platform->comm.mpiComm,
                                                               0);

  dfloat mue, rho;
  platform->options.getArgs("VISCOSITY", mue);
  platform->options.getArgs("DENSITY", rho);
  const dfloat nu = mue / rho;

  if (platform->comm.mpiRank == 0) {
    printf("  time= %g  enst= %g  energy= %g  -2*nu*enst= %g", time, enstrophy, energy, -2 * nu * enstrophy);
  }

  static dfloat energyComputed[3] = {0};

  if (tstep) {
    dfloat sum = 0.0;
    for (int i = 0; i < nrs->nBDF; ++i) {
      sum += nrs->coeffBDF[i] * energyComputed[i];
    }
    energyComputed[2] = energyComputed[1];
    energyComputed[1] = energyComputed[0];
    energyComputed[0] = energy;
    const dfloat dissipationRate = (nrs->g0 * energy - sum) / nrs->dt[0];
    const dfloat nuEff = -dissipationRate / (2 * enstrophy);
    if (platform->comm.mpiRank == 0) {
      printf("  d(energy)/dt= %g  nuEff/nu= %g", dissipationRate, nuEff / nu);
    }
  } else {
    energyComputed[0] = energy;
  }

  if (platform->comm.mpiRank == 0) {
    printf("\n");
  }
}

/* UDF Functions */

void UDF_Setup0(MPI_Comm comm, setupAide &options)
{
  dfloat eps;
  platform->par->extract("casedata", "eps", eps);
  if (platform->options.compareArgs("BUILD ONLY", "FALSE")) {
    double *const nek_cb_scnrs = (double *)nek::ptr("cb_scnrs");
    nek_cb_scnrs[0] = eps;
  }
}

void UDF_Setup(nrs_t *nrs)
{
    // gnn plugin
    graph = new gnn_t(nrs);
    graph->gnnSetup();
    graph->gnnWrite();

    // set IC
    mesh_t *mesh = nrs->meshV;

    dfloat U0, V0, W0;
    platform->par->extract("casedata", "U0", U0);
    platform->par->extract("casedata", "V0", V0);
    platform->par->extract("casedata", "W0", W0);

    if (platform->options.getArgs("RESTART FILE NAME").empty()) 
    {
        for (int n = 0; n < mesh->Nlocal; n++) 
        {
            const auto x = mesh->x[n];
            const auto y = mesh->y[n];
            const auto z = mesh->z[n];
            nrs->U[n + 0 * nrs->fieldOffset] = sin(x) * cos(y) * cos(z) + U0;
            nrs->U[n + 1 * nrs->fieldOffset] = -cos(x) * sin(y) * cos(z) + V0;
            nrs->U[n + 2 * nrs->fieldOffset] = W0;
        }
    }

    if (platform->comm.mpiRank == 0)
    {
        std::cout << "fieldOffset: " << nrs->fieldOffset << std::endl;
        std::cout << "Nelements: " << mesh->Nelements << std::endl;
        std::cout << "Np: " << mesh->Np << std::endl;
        std::cout << "Nq: " << mesh->Nq << std::endl;
        std::cout << "Nlocal: " << mesh->Nlocal << std::endl;
    }
}

void UDF_ExecuteStep(nrs_t *nrs, dfloat time, int tstep)
{
    printDiagnostics(nrs, time, tstep);

    if (nrs->isOutputStep) 
    {
        nek::ocopyToNek(time, tstep);
        nek::userchk();
    }

    if (nrs->lastStep)
    {
        // write flowfield 
        int rank, size; 
        MPI_Comm_rank(platform->comm.mpiComm, &rank);
        MPI_Comm_size(platform->comm.mpiComm, &size);

        dlong n_nodes = nrs->meshV->Np * nrs->meshV->Nelements; 
        std::string irank = "_rank_" + std::to_string(rank);
        std::string nranks = "_size_" + std::to_string(size); 
        writeToFile("gnn_outputs/x" + irank + nranks, nrs->U, n_nodes, 3);
        writeToFile("gnn_outputs/y" + irank + nranks, nrs->P, n_nodes, 1);
        delete graph;
    }
}
